# large_square

1. [Задание](#subject)
2. [Компиляция и запуск](#compile)
3. [Алгоритм решения](#algo)
4. [Генератор карт](#mapgen)
5. [Makefile](#makefile)

### Задание
Требуется найти самый большой квадрат на карте, избегая препятствий. 
Программа должна заменять "пустые" символы на "заполнитель", чтобы воспроизвести наибольший возможный квадрат. 
Если существует более 1 решения, воспроизводится квадрат, который ближе остальных к верхнему левому краю карты.
#### Требования:
- В основном каталоге должен быть исполняемый файл lsq, а также действующий Makefile для сборки проекта.
- В качестве аргумента программе передается 1 до N файлов, содержащих карту. 
- Если карта неправильная (не соответствует критериям), то программа должна отобразить ошибку 'map error'. 
- Каждый результат (или ошибка) должны быть отделены пустой строкой. Результат обработки последнего файла пустой строкой не сопровождается.
- Если в качестве агрументов ничего не передается, программа должна уметь читать со стандартного ввода. 
- Можно использовать только следующие функции: exit, open, close, write, read, malloc и free.

#### Шаблон карты:
- Первая строка карты содержит информацию:
	- Количество линий на карте
	- Символ "пустоты"
	- Символ "препятствия"
	- Символ "заполнитель".

#### Критерии правильности карты:
- Все строки должны иметь одинаковую длину
- Есть хотя бы 1 строка с 1 символом
- Каждая строка заканчивается символом переноса строки
- Символы и количество строк на карте должны соответствовать тем, которые введены в первой строке.

---
<div id='compile'/>

### Компиляция и запуск
Сборка исполняемого файла программы осуществляется с помощью утилиты GNU Make. Ниже можно подробно ознакомиться с используемым [make-файлом](#makefile).

###### Пример работы программы

```bash
%>cat -e example_file
10.ox$
.o....oo..$
o.........$
..o.o..o..$
..........$
..o.......$
..........$
o.........$
...o......$
..o.......$
.....o....$
%>./lsq example_file
.o....oo..
o.........
..o.o..o..
....xxxxxx
..o.xxxxxx
....xxxxxx
o...xxxxxx
...oxxxxxx
..o.xxxxxx
.....o....
%>./lsq map1 map2 map3 map4 map5
map error

map error

.o....oo.o
o.........
..o.o..o..
....xxxxxx
...oxxxxxx
....xxxxxx
o...xxxxxx
...oxxxxxx
..o.xxxxxx

x

map error
```

---
<div id='algo'/>
### Алгоритм решения
Для решения задачи используется метод динамического программирования. Он позволяет шаг за шагом для каждой ячейки определить размер квадрата, который можно из нее построить, используя результаты предыдущих шагов. Преимуществом данного способа решения является то, что легко учесть препятствие на карте.

Из исходной карты создается карта поиска. Символ-препятствие заменяется на 0, символ-пустота на 1.
Для катрты изображенной ниже:
![start](https://user-images.githubusercontent.com/49130229/65821660-28fe0b00-e241-11e9-9a3b-bf61dfb650a7.png)

Карта поиска примет следующий вид:
![search](https://user-images.githubusercontent.com/49130229/65821663-2996a180-e241-11e9-98fc-89f0fa986aa2.png)

После для каждой ячейки рассчитывается, какого размера получится квадрат, если данная ячейка будет его правым нижним углом. Ячейка, в которой величина окажется наибольшей, является ключом к определению области на карте, в которую необходимо поместить символ-заполнитель.

Так как каждая ячейка рассматривается как правый нижний угол потенциального квадрата, то нужно анализировать величины, которые находятся слева сверху. Ячейки в первой строке и первом столбце таких соседних ячеек не имеют или их недостаточно, чтобы составить квадрат (далее это будет видно наглядно). Таким образом, из этих ячеек невозможно составить квадрат с размером строны больше единицы. Поэтому решением задачи в таких условиях будет являться заполнение ячейки, которая ближе всего к левому верхнему углу.

Алгоритм поиска размера начинается со 2 ячейки во второй строке. Происходит сравнение значений ячеек слева, сверху и сверху слева. Из них выбирается наименьшее и складывается со значением текущей ячейки. Результат помещается в текущую ячейку.
![solve_part](https://user-images.githubusercontent.com/49130229/65821661-2996a180-e241-11e9-9348-c4453184d5a8.png)

Таким образом, получившееся значение внутри ячейки будет размером квадрата, который можно из нее построить; также это область с которой начнется (заончится) заполнение карты.
В цикле осуществляется переход по каждой ячейке, для нее проводится аналогичный расчет. В результате карта поиска примет вид:
![solve](https://user-images.githubusercontent.com/49130229/65821662-2996a180-e241-11e9-930c-30a95f6c26fa.png)

Ячейки, значения которых равны нулю, в рассчете не участвуют. Это позволяет учесть наличие препятствия. Если рядом с рассматриваемой ячейкой есть ячейка с нулем, то среди соседей она всегда будет наименьшей. Значит, в текущей ячейке нельзя получить значение, отличное от единицы. В результате расчета с текущей ячейкой ничего не поменяется. Таким образом, ячейка с нулем не позволяет сохранить информацию для описания возможной области построения.

Иногда после расчета карты получается несколько ячеек с наибольшими значениями, читай областей, из которых должна быть построена карта. Тут нужно вспомнить условие задачи. Оно гласит, что при наличии нескольких решений выбирается область, ближайшая к левому верхнему краю карты. Значит из полученных значений подойдет то, которое ближе к левому верхнему краю. В программе такая ячейка определяется перебором всех значений карты поиска. Первое попавшееся будет являться решением.

После получения наибольшего значения в ячейке, осуществляется рассчет области, которая будет заполнена требуемыми символами. Для данной карты результат выглядит так:
![answer](https://user-images.githubusercontent.com/49130229/65821664-2a2f3800-e241-11e9-82a8-4940cfe3f151.png)

---
<div id='mapgen'/>
### Генератор карт
Генератор карт на Python3

```python
#!/usr/bin/python3
# -*- coding: utf-8 -*-

from sys import argv
from random import randint

if (len(argv) == 7):
	try:
		row = int(argv[1])
		col = int(argv[2])
		density = int(argv[3])
		empty = argv[4]
		obstacle = argv[5]
		full = argv[6]
		if (len(empty) + len(obstacle) + len(full)) == 3:
			print(str(row) + empty + obstacle + full)
			for line in range(row):
				for el in range(col):
					if ((randint(1, row) * 2) < density):
						print(obstacle, end = '')
					else:
						print(empty, end = '')
				print()
		else:
			print('input error: enter valid characters')
	except ValueError:
		print('input error: enter valid numbers')
```

---
<div id='makefile'/>
### Makefile
В данном разделе приведены описания используемых конструкций утилиты GNU Make. Изначально это были комментарии, которые я оставлял в процессе изучения данного инструмента. Они получились достаточно объемными, поэтому было решено вынести их отдельно.

Специальная цель .PHONY в качестве зависимостей содержит названия астрактных действий. Эта цель нужна:
- чтобы не искать среди файлов имена абстрактных действий
- если файл назван как действие, действие будет пропущено

```make
.PHONY: all clean fclean re
```

Переменная name содержит название исполняемого файла

```make
name := lsq
```

Переменная src_dirs содержит имена директорий, в которых расположены исходные и заголовочные файлы:

```make
src_dirs := list func main
```

Переменная src_files содержит список исходных файлов:

```make
src_files := $(notdir $(wildcard $(addsuffix /*.c, $(src_dirs))))
```

__Получение списка исходных файлов:__
- `addsuffix` добавляет к названиям директорий часть `/*.c` для описания всех файлов .c: `dir/*.c` ;
- `wildcard` из полученного шаблона для заданной директории формирует
- список файлов, удовлетворяющих шаблону: `dir/main.c`, `dir/func.c` и т.д. ;
- `notdir` стирает из имени файла имя директории : `main.c`, `func.c` и т.д.

Переменная obj_files содержит список объектных файлов, которые нужно получить в процессе компиляции:

```make
obj_files := $(patsubst %.c, %.o, $(src_files))
```

__Получение списка объектных файлов:__
- `patsubst` принимает шаблон для исходных слов, шаблон для новых слов, исходные слова
- функция заменяет указанным образом слова, подходящие под шаблон

Цель all является основной. Перед ее выполнением будет проверяться, есть ли исполняемый файл. Если нет, то выполняется правило для исполняемого файла:

```make
all: $(name)
```

Для следующего правила будет проверяться, есть ли объектные файлы на диске, если нет, то выполняется шаблонное правило для объектных файлов, если все объектные файлы есть, выполняется команда компиляции исполняемого файла:

```make
$(name): $(obj_files)
	gcc $(obj_files) -o $(name)
```

Переменная VPATH задает директории, где шаблонные правила будут искать зависимости:

```make
VPATH := $(src_dirs)
```

Это шаблонное правило используется, чтобы не прописывать много одинаковых правил для каждого объектного файла. В правиле файлы задаются шаблоном и проверяется, чтобы для каждого файла с расширением .o был файл с расширением .c, если этого файла не будет, то выполнение Makefile прервется:

```make
%.o: %.c
	gcc -с -MD $(addprefix -I , $(src_dirs)) $<
```

Опция -MD позволяет компилятору построить список зависимостей исходных и заголовочных файлов. Результат сохраняется в файлах .d
Содержимое файла ft_list_push_back.d:
>ft_list_push_back.o: list/ft_list_push_back.c /usr/include/stdc-predef.h list/ft_list.h

Так как шаблонное правило применяется к разным файлам, то необходимы автоматические переменные. Только они позволяют понять, для каких файлов сейчас задействуется правило.
`$<` - автоматическая переменная - имя первой зависимости обрабатываемого файла.

Директива include позволяет включать в выполняемый make-файл другие файлы. Когда эта конструкция встречается, утилита make останавливает обработку текущего файла и переключается на файл в директиве. В данном случае обрабатываются файлы зависимостей .d

```make
include $(wildcard *.d)
```

Правило clean описывает удаление файлов .o и .d

```make
clean:
	/bin/rm -f *.o
	/bin/rm -f *.d
```

Правило fclean описывает удаление исполняемого файла, а также файлов .o и .d

```make
fclean: clean
	/bin/rm -f $(name)
```

Правило описывает удаление файлов и новую сборку проекта.

```make
re: fclean all
```

Больше информации по работе с утилитой GNU Make можно получить [здесь](http://embedded.ifmo.ru/sdk/sdk11/soft/make/make.pdf).

