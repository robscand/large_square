/* *************** */
/* ***** lsq ***** */
/* *************** */

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include "ft_func.h"
#include "ft_list.h"

#define BUF_SIZE 13 /* максимальная длина строки с описанием карты: */
/* максимальный размер типа int (10 чисел) + символы описания карты (3 символа) */

/* Функция map_clear предназначена для удаления памяти, выделенной под карту */ 
/* перед обработкой следующей карты или завершения работы программы */
/* В качестве аргументов передаются указатель на область памяти, */
/* которая требует очистки, размер карты */
void	map_clear(char ***map, int size[2])
{
  int i;

  i = 0;
  /* удаление карты */
  if (*map)
    if (size[0] != 0 && size[1] != 0)
      {
	while (i < size[0])
	  {
	    free(*((*map) + i));
	    i++;
	  }
	free(*map);
	map = NULL;
      }
}

/* Функция read_params предназначена для разбора строки с описанием шаблона карты */
/* и сохранения всех необходимых характеристик карты */
/* В качестве аргументов передается файловый дескриптор, пустой массив для размера, */
/* временный список для сохранения первой строки карты и расчета длины строки */
/* пустой массив для символов карты - легенда. */
/* Функция возвращает статус выполнения. Если 1, то есть ошибка */
int	read_params(int fd, t_list **temp, int size[2], char leg[3])
{
  char		buf[BUF_SIZE + 1]; /* буфер для всего шаблона */
  char		bnum[BUF_SIZE + 1 - 3]; /* буфер для числа строк */
  char		c;
  int		i;

  i = 0;
  /* пока файл не пуст и строка с шаблоном карты не кончилась, сохраняем шаблон в буфер */
  while (read(fd, &c, 1) > 0 && c != '\n')
    {
      buf[i] = c;
      i++;
    }
  buf[i] = '\0';
  if (*buf == '\0') /* статус 1. пришел пустой файл */
    return (1);
  /* сохранение количества линий */
  ft_strncpy(bnum, buf, ft_strlen(buf) - 3); /* 3 последних символа не относится к числу строк */
  bnum[ft_strlen(buf) - 3] = '\0';
  size[0] = ft_atoi(bnum);
  if (size[0] <= 0) /* статус 1. число в первой строке неправильное */
    return (1);
  /* сохранение символов карты */
  leg[0] = buf[i - 3]; /* символ "пустоты" */
  leg[1] = buf[i - 2]; /* символ "препятствие" */
  leg[2] = buf[i - 1]; /* сивол "заполнение" */
  /* Чтобы посчитать количество элементов в первой строке, */
  /* нужно пройти по каждому символу. */
  /* Это нужно, чтобы выделить память под размер карты. */
  /* При этом эти элементы нужно сохранить. */
  /* Так как lseek не используется, то заново прочитать строку нельзя, */
  /* нужно открывать файл заново. */
  /* Чтобы этого не делать, элементы первой строки во время подсчета */
  /* будут сохраняться во временный односвязный список. */
  while (read(fd, &c, 1) > 0 && c != '\n')
      ft_list_push_back(temp, &c);
  size[1] = ft_list_size(*temp);
  if (size[1] == 0) /* статус 1. карта отсутствует */
    return (1);
  return (0); /* статус 0. параметры успешно считаны */
}

/* Функция read_map предназначена для считывания карты */
/* из файла (стандартного ввода) в двумерный массив. */
/* В качестве аргументов функция принимает файловый дескриптор, */
/* указатель под массив карты, указатель на временный список, размеры карты. */
/* Функция возвращает статус выполнения. Если 1, то есть ошибка */
int	read_map(int fd, char ***map, t_list *temp, int size[2])
{
  char		**m;
  char		c;
  int		el;
  int		row;

  row = 0; /* количество строк = числу символов переноса на карте */
  /* выделение памяти под карту */
  m = (char **)malloc(size[0] * sizeof(char *));
  while (row < size[0])
    {
      m[row] = (char *)malloc(size[1] * sizeof(char));
      row++;
    }
  *map = m;
  el = 0; /* количество элементов в строке */
  row = 0;
  /* из временного списка осуществляем перезапись в массив */
  while (temp)
    {
      m[row][el] = *(temp->data);
      el++;
      temp = temp->next;
    }
  row++; /* считывание новой cтроки*/
  el = 0; /* 1 элемент строки */
  /* пока карта не закончится считываем символы в массив */
  while (row < size[0])
    {
      if (read(fd, &c, 1) > 0 && c != '\0') /* условие вынесено в отдельную строчку, чтобы не прочитывался лишний символ */
	{
	  if (c != '\n')
	    m[row][el] = c;
	  else
	    {
	      row++;
	      if (el != size[1]) /* статус 1. количество символов в данной строке */
		return (1);	     /* отличается от количества символов в первой */
	      el = -1; /* при выходе из условия нужно начать считать элементы заново */
	    }
	  el++;
	}
      else /* строк меньше, чем в шаблоне -> цикл будет бесконечный */
	break;
    }
  if (read(fd, &c, 1) > 0 || row != size[0]) /* статус 1. карта продолжается после символа конца строки */
    return (1);					   /* или количество строк на карте отличается от количества в шаблоне*/
  return(0); /* статус 0. карта успешно прочитана */
}

/* Функция check_map предназначена для проверки правильности */
/* содержания карты. Она должна состоять только из "пустых" символов */
/* и символов "препятствий" */
int	check_map(char **m, int size[2], char leg[3])
{
  int i;
  int j;

  i = 0;
  while (i < size[0])
    {
      j = 0;
      while (j < size[1])
	{
	  if (m[i][j] != leg[0] && m[i][j] != leg[1])
	    return (1); /* статус 1. карта не соответствует шаблону */
	  j++;
	}
      i++;
    }
  return (0); /* статус 0. содержимое карты соответствует шаблону */
}

/* функция предназначена для выполнения преобразований над файлами */
/* или преобразования данных со стандартного потока */
/* На вход подается указатель на название файла */
void	open_file(char *file)
{
  int		fd;
  int		size[2];
  char		leg[3];
  char		**map;
  t_list	*tmp;
  
  /* если был передан указатель на файл, то открываем его на чтение (fd = 1), */
  /* иначе будем читать со стандартного потока (fd = 0) */
  fd = 0;
  tmp = NULL;
  map = NULL;
  size[0] = 0;
  size[1] = 0;
  if (file)
    fd = open(file, O_RDONLY);
  if (read_params(fd, &tmp, size, leg))
    {
      ft_putstr("map error\n");
      ft_list_clear(&tmp);
      return;
    }
  if (read_map(fd, &map, tmp, size))
    {
      ft_putstr("map error\n");
      map_clear(&map, size);
      ft_list_clear(&tmp);
      return;
    }
  /* список больше не нужен - освобождение памяти */
  ft_list_clear(&tmp);
  if (check_map(map, size, leg))
    {
      ft_putstr("map error\n");
      map_clear(&map, size);
      return;
    }
  solve_lsq(map, size, leg);
  map_clear(&map, size);
}

int	main(int cnt, char **file)
{
  if (cnt == 1)
    {
      open_file(NULL);
    }
  else
    {
      file++; /* пропускаем название программы */
      while (cnt > 1)
	{
	  open_file(*file);
	  file++;
	  cnt--;
	  if (cnt != 1)
	    ft_putchar('\n'); /* если файл не последний в очереди, то отделяем его пустой строкой */
	}
    }
  return (0);
}
